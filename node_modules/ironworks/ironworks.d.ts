
///<reference path='./typings/master.d.ts' />

declare module "ironworks" {
    import hapi = require('hapi');
    import events = require('eventemitter2');
    import redis = require('redis');

    export module helpers {
        export module idHelper {
            export function newId(): string;
        }
    }
    export module options {
        export class Options<I> {
            constructor(defaults: I);
            public get<getI>(dotDelimitedKey: string, root?: any): getI;
            public has(dotDelimitedKey: string): boolean;
            public beAdoptedBy<parentI>(parentDefs: I, childName: string): Options<I>;
            public merge(newOpts: I);
        }
        export interface IWorkerOpts {}
        export interface ISocketWorkerOpts {}
        export interface IServiceOpts {
            dependencyCheckTimeout?: number;
            dependencyCheckFrequency?: number;
            service?: IWorkerOpts;
            comm?: ICommOpts;
            workerName?: string;
        }
        export interface IHttpWorkerOpts {
            port?: number;
            apiUri?: string;
            rootSitePagePath?: string;
            hapi?: hapi.IServerOptions;
        }
        export interface IEventerOpts {
            eventEmitter2Config?: {
                wildcard?: boolean
                delimiter?: string
                newListener?: boolean
                maxListeners?: number
            }
        }
        export interface ICommOpts {
            prefix?: string
            worker?: IWorkerOpts
        }
        export interface ICollectionOpts {
            eventer?: IEventerOpts;
        }
        export interface ICfClientWorkerOpts {
            iwProperty: string;
            vcapServices: string;
        }
        export interface ILogWorkerOpts {}
        export interface IRedisWorkerOpts{
            vcapServices: string;
            redisProp: string;
        }
    }
    export module workers {
        export interface IWorker extends whoIAm.IWho, eventing.IEventer {
            comm: eventing.IComm;
            running: boolean;

            init(callback?:(e:Error) => void);
            start(dependencies:collection.ICollection<IDependency<IWorker>>, callback?:(e:Error) => void);

            getDependencyNames(): string[];
            getComm(): eventing.IComm;
        }
        export class Worker implements IWorker {
            comm:eventing.IComm;
            running:boolean;

            constructor(dependencyNames: string[], comm: eventing.IComm, whoService: whoIAm.IAm, whoAmI: whoIAm.IAm, opts?: options.IWorkerOpts);

            public init(callback: (e: Error) => void);

            public start(dependencies?: collection.ICollection<IDependency<IWorker>>, callback?: (e: Error) => void);

            public who(callback?: (e: Error, me: whoIAm.IAm) => void): whoIAm.IAm;

            public getDependencyNames(): string[];
            public getComm(): eventing.IComm;
            public getLastEvent(): string;

            public tell(event: eventing.ICommEmit|string): boolean;
            public inform<infoType>(event: eventing.ICommEmit|string, info: infoType): boolean;
            public confirm(event: eventing.ICommEmit|string, callback: (e: Error) => void): boolean;
            public check<checkType>(event: eventing.ICommEmit|string, toCheck: checkType, callback: (e: Error) => void): boolean;
            public ask<answerType>(event: eventing.ICommEmit|string, callback: (e: Error, answer?: answerType) => void): boolean;
            public request<requestType, responseType>(
                event: eventing.ICommEmit|string, request: requestType, callback: (e: Error, response?: responseType) => void)
            : boolean;

            public listen(event: eventing.ICommEvent|string, listener: () => void): IWorker;
            public info<infoType>(event: eventing.ICommEvent|string, listener: (info: infoType) => void): IWorker;
            public ack(event: eventing.ICommEvent|string, listener: (callback: (e: Error) => void) => void): IWorker;
            public verify<checkType>(
                event: eventing.ICommEvent|string, listener: (toCheck: checkType, callback: (e: Error) => void) => void)
            : IWorker;
            public answer<answerType>(
                event: eventing.ICommEvent|string, listener: (callback: (e: Error, answer?: answerType) => void) => void
            ): IWorker;
            public respond<requestType, responseType>(
                event: eventing.ICommEvent|string, listener: (request: requestType, callback: (e: Error, response?: responseType) => void) => void
            ): IWorker;
            public onlyOnce(): IWorker;
            public dispose(callback?: () => void);
        }

        export interface ISocketWorker extends IWorker {}
        export class SocketWorker extends Worker implements ISocketWorker {
            public socketServer:any; //TODO: how do we type this?
            constructor(comm: eventing.IComm, whoService:whoIAm.IAm, opts?:options.ISocketWorkerOpts);
            public start(dependencies:collection.ICollection<IDependency<IWorker>>, callback?:(e:Error) => void);
            public dispose(callback?:() => void);
        }

        export interface IHttpWorker extends IWorker {
            httpServer: hapi.Server;
        }
        export class HttpWorker extends Worker implements IHttpWorker {
            public httpServer: hapi.Server;
            constructor(comm: eventing.IComm, whoService: whoIAm.IAm, opts?: options.IHttpWorkerOpts);
            public init(callback?: (e: Error) => void);
            public start(dependencies: collection.ICollection<IDependency<IWorker>>, callback?: (e: Error) => void);
            public dispose(callback?: () => void);
        }

        export interface IDependency<T extends IWorker> extends whoIAm.IWho {
            value?: T;
        }

        export interface ICfClientWorker extends IWorker {
            userProvidedServices: ICfClient[];
        }
        export class CfClientWorker extends Worker implements ICfClientWorker{
            public userProvidedServices: ICfClient[];
            constructor(comm: eventing.IComm, whoService: whoIAm.IAm, opts?: options.ICfClientWorkerOpts);
            public init(callback: (e: Error) => void);
            public start(dependencies: collection.ICollection<IDependency<IWorker>>, callback?: (e: Error) => void);
            public dispose(callback?: () => void);
        }
        export interface ICfClient {
            serviceName: string;
            protocol: string;
            host: string;
            port: string;
            route: string;
            token: string;
        }

        export interface IRedisWorker extends IWorker {
            redisService: IRedisService;
            client: redis.RedisClient;
        }
        export class RedisWorker extends Worker implements IRedisWorker{
            public redisService: IRedisService;
            public client: redis.RedisClient;

            constructor(comm: eventing.IComm, service: whoIAm.IAm, opts?: options.IRedisWorkerOpts);
            public init(callback: (e: Error) => void);
            public start(dependencies: collection.ICollection<IDependency<IWorker>>, callback?: (e: Error) => void);
            public dispose(callback?: () => void);
        }
        export interface IRedisService {
            hostname: string;
            port: string;
            password: string;
        }

        export interface ILogWorker extends IWorker {}
        export class LogWorker extends Worker implements ILogWorker {
            constructor(comm: eventing.IComm, whoService: whoIAm.IAm, writeStdout?: Function, writeStderr?: Function, opts?: options.ILogWorkerOpts);
            public start(dependencies: collection.ICollection<IDependency<IWorker>>, callback: (e: Error) => void);
        }
    }
    export module service {
        export interface IService extends workers.IWorker {
            use(worker:workers.IWorker): IService;
            inject(injector:(service:IService, use:(worker:workers.IWorker) => void) => void): IService;
            disposeWorkers(callback:() => void);
            get(workerQuery:whoIAm.IWhoQuery, callback:(e:Error, results:collection.ICollection<workers.IWorker>) => void): IService;
        }
        export class Service extends workers.Worker implements IService {
            constructor(name: string, opts?: options.IServiceOpts);
            public start(dependencies: collection.ICollection<workers.IDependency<IService>>, callback?: (e: Error) => void);
            public who(callback?: (e: Error, me: whoIAm.IAm) => void): whoIAm.IAm;
            public use(worker: workers.IWorker): IService;
            public inject(injector: (service: IService, use: (worker: workers.IWorker) => void) => void): IService;
            public get(workerQuery: whoIAm.IWhoQuery, callback: (e: Error, results: collection.ICollection<workers.IWorker>) => void): IService;
            public getLastEvent(): string;
            public disposeWorkers(callback: () => void);
            public dispose(callback?: () => void) ;
        }
        export interface IServiceReady {
            service: IService
        }
    }
    export module interception {
        export interface IInterceptedInform<infoType> {
            (   meta: eventing.ICommEmit,
                info: infoType,
                next: (info: infoType) => void,
                stop: () => void
            ): void;
        }
        export interface IInterceptedConfirm {
            (   meta: eventing.ICommEmit,
                next: (callback: (e: Error) => void) => void,
                emit: (intercept: (e: Error) => void) => void,
                stop: () => void
            ): void;
        }
        export interface IInterceptedAsk<answerType> {
            (   meta: eventing.ICommEmit,
                callback: (e: Error, response?: answerType) => void,
                next: (callback: (e: Error, answer?: answerType) => void) => void,
                emit: (intercept: (e: Error, answer?: answerType) => void) => void,
                stop: () => void
            ): void;
        }
        export interface IInterceptedRequest<requestType, responseType> {
            (   meta: eventing.ICommEmit,
                request: requestType,
                callback: (e: Error, response?: responseType) => void,
                next: (request: requestType, callback: (e: Error, response?: responseType) => void) => void,
                emit: (intercept: (e: Error, response?: responseType) => void) => void,
                stop: () => void
            ): void;
        }
        export interface IInterceptedTell {
            (   meta: eventing.ICommEmit,
                next: () => void,
                stop: () => void
            ): void;
        }
        export interface IInterceptor extends whoIAm.IWho {
            getEvent(): eventing.ICommEvent;
            getComm(): eventing.IComm;

            intercept(
                emit: eventing.ICommEmit,
                eventArgs: any[],
                listener: Function,
                interception: (stop: boolean, updatedArgs: any[]) => void
            );

            listen(interceptor:IInterceptedTell): eventing.IComm;
            info<infoType>(interceptor:IInterceptedInform<infoType>): eventing.IComm;
            ack(interceptor:IInterceptedConfirm): eventing.IComm;
            answer<answerType>(interceptor:IInterceptedAsk<answerType>): eventing.IComm;
            respond<requestType, responseType>(interceptor:IInterceptedRequest<requestType, responseType>): eventing.IComm;
        }
    }
    export module eventing {
        export interface IEventData {
            name: string;
        }
        export interface IEvent extends IEventData {
            getText(): string;
        }
        export class Event implements IEvent {
            name: string;

            constructor(data: IEventData);
            public getText(): string;
        }

        export interface IEmitData extends IEventData {
            id: string;
            emitter: whoIAm.IAm;
            timestamp: number;
        }
        export interface IEmit extends IEmitData, IEvent {}
        export class Emit extends Event implements IEmit {
            timestamp: number;
            id: string;
            emitter: whoIAm.IAm;

            constructor(data: IEmitData);
        }

        export interface ICommEventData extends IEventData {
            prefix: string;
            service: string;
            method: string;
            worker: string;
        }
        export interface ICommEvent extends ICommEventData, IEvent {}
        export class CommEvent extends Event implements ICommEvent {
            prefix: string;
            service: string;
            method: string;
            worker: string;

            constructor(event: ICommEventData|string);
            public getText(): string;
        }

        export interface ICommEmitData extends IEmitData, ICommEventData {}
        export interface ICommEmit extends ICommEmitData, IEmit {}
        export class CommEmit extends eventing.CommEvent implements ICommEmit {
            timestamp: number;
            id: string;
            emitter: whoIAm.IAm;
            constructor(data: ICommEmitData);
        }

        export interface IComm extends IEventer {
            prefix(): string;
            intercept(event:ICommEventData|string): interception.IInterceptor
            start(callback?:(e:Error) => void);
        }
        export class Comm extends Eventer implements IComm {
            public running: boolean;

            constructor(service: whoIAm.IAm, whoAmI: whoIAm.IAm, serviceWorkerName: string, opts?: options.ICommOpts);
            public init(callback: (e: Error) => void);
            public start(callback?: (e: Error) => void);
            public prefix(): string;
            public who(callback?: (e: Error, me: whoIAm.IAm) => void): whoIAm.IAm;
            public getDependencyNames(): string[];
            public getComm(): IComm;
            public tell(event: ICommEmit|string): boolean;
            public inform<infoType>(event: ICommEmit|string, info: infoType): boolean;
            public confirm(event: ICommEmit|string, callback: (e: Error) => void): boolean;
            public ask<answerType>(event: ICommEmit|string, callback: (e: Error, answer?: answerType) => void): boolean;
            public request<requestType, responseType>(
                event: ICommEmit|string, request: requestType, callback: (e: Error, response?: responseType) => void)
            : boolean;
            public intercept(event: ICommEventData|string): interception.IInterceptor;
            public listen(event: ICommEvent|string, listener: () => void): IComm;
            public info<infoType>(event: ICommEvent|string, listener: (info: infoType) => void): IComm;
            public ack(event: ICommEvent|string, listener: (callback: (e: Error) => void) => void): IComm;
            public answer<answerType>(
                event: ICommEvent|string, listener: (callback: (e: Error, answer?: answerType) => void) => void
            ): IComm;
            public respond<requestType, responseType>(
                event: ICommEvent|string,
                listener: (request: requestType, callback: (e: Error, response?: responseType) => void) => void)
            : IComm;
            public onlyOnce(): IComm;
            public dispose(callback?: () => void);
        }

        export interface IEventer {
            getLastEvent(): string

            tell(event:IEmit|string): boolean;

            inform<infoType>(event:IEmit|string,
                             info:infoType): boolean;

            confirm(event:IEmit|string,
                    callback:(e:Error) => void): boolean;

            check<checkType>(
                event: IEmit|string,
                toCheck: checkType,
                callback: (e: Error) => void
            ): boolean;

            ask<answerType>(event:IEmit|string,
                            callback:(e:Error, answer?:answerType) => void): boolean;

            request<requestType, responseType>(event:IEmit|string,
                                               request:requestType,
                                               callback:(e:Error, response?:responseType) => void): boolean;


            listen(event:IEvent|string,
                   listener:() => void): IEventer;

            info<infoType>(event:IEvent|string,
                           listener:(info:infoType) => void): IEventer;

            ack(event:IEvent|string,
                listener:(callback:(e:Error) => void) => void): IEventer;

            verify<checkType>(
                event: IEvent|string,
                listener:
                    (toCheck: checkType, callback: (e: Error) => void) => void
            ): IEventer;

            answer<answerType>(event:IEvent|string,
                               listener:(callback:(e:Error, answer?:answerType) => void) => void): IEventer;

            respond<requestType, responseType>(event:IEvent|string,
                                               listener:(request:requestType, callback:(e:Error, response?:responseType) => void) => void): IEventer;

            onlyOnce(): IEventer;

            dispose(callback?:() => void);
        }
        export class Eventer extends events.EventEmitter2 implements IEventer {
            constructor(opts?: options.IEventerOpts);
            public getLastEvent(): string;
            public tell(event: IEmit|string): boolean;
            public inform<infoType>(event: IEmit|string, info: infoType): boolean;
            public confirm(event: IEmit|string, callback: (e: Error) => void): boolean;
            public check<checkType>(event: IEmit|string, toCheck: checkType, callback: (e: Error) => void): boolean;
            public ask<answerType>(event: IEmit|string, callback: (e: Error, answer?: answerType) => void): boolean;
            public request<requestType, responseType>(
                event: IEmit|string, request: requestType, callback: (e: Error, response?: responseType) => void)
            : boolean;
            public listen(event: IEvent|string, listener: () => void): IEventer;
            public info<infoType>(event: IEvent|string, listener: (info: infoType) => void): IEventer;
            public ack(event: IEvent|string, listener: (callback: (e: Error) => void) => void): IEventer;
            public verify<checkType>(
                event: IEvent|string, listener: (toCheck: checkType, callback: (e: Error) => void) => void)
            : IEventer;
            public answer<answerType>(
                event: IEvent|string, listener: (callback: (e: Error, answer?: answerType) => void) => void)
            : IEventer;
            public respond<requestType, responseType>(
                event: IEvent|string,
                listener: (request: requestType, callback: (e: Error, response?: responseType) => void) => void)
            : IEventer;
            public onlyOnce(): IEventer;
            public dispose(callback?: () => void);
        }
    }
    export module whoIAm {
        export interface IAm {
            id: string;
            name: string;
        }
        export interface IWho {
            who(callback?:(e:Error, me:IAm) => void): IAm;
        }
        export interface IWhoQuery {
            names?: string[];
            ids?: string[];
            op?: string;
        }
    }
    export module collection {
        export interface ICollection<whoType extends whoIAm.IWho> extends whoIAm.IWho {
            add(item:whoType): ICollection<whoType>;
            addMany(items:whoType[]): ICollection<whoType>;
            remove(query:whoIAm.IWhoQuery, callback?:(e:Error, result:ICollection<whoType>) => void);
            get(query:whoIAm.IWhoQuery, callback:(e:Error, result:ICollection<whoType>) => void);
            clear(): ICollection<whoType>;
            list(): whoType[];
            each(iterator:(item:whoType, itemDone:(e:Error) => void) => void, allDone?:(e:Error) => void);
            filter(iterator:(item:whoType, check:(e:Error, include:boolean) => void) => void,
                   done:(e:Error, results:ICollection<whoType>) => void);
            length(): number;
            dispose(callback?:() => void);
        }
        export class Collection<whoType extends whoIAm.IWho> implements ICollection<whoType> {
            constructor(id: string, opts?: options.ICollectionOpts);
            public who(callback?: (e: Error, me: whoIAm.IAm) => void): whoIAm.IAm;
            public add(item: whoType): ICollection<whoType>;
            public addMany(items: whoType[]);
            public remove(query: whoIAm.IWhoQuery, callback?: (e: Error, removed: ICollection<whoType>) => void);
            public get(query: whoIAm.IWhoQuery, callback: (e: Error, result: ICollection<whoType>) => void);
            public list(): whoType[];
            public clear(): ICollection<whoType>;
            public each(iterator: (item: whoType, itemDone: (e: Error) => void) => void, allDone?: (e: Error) => void);
            public filter(
                iterator: (item: whoType, check: (e: Error, include: boolean) => void) => void,
                done: (e: Error, results: ICollection<whoType>) => void
            );
            public length(): number;
            public dispose(callback?: () => void);
        }
    }
}
