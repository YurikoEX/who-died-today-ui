var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var events = require('eventemitter2');
var _ = require('lodash');
var async = require('async');
var idHelper = require('../helpers/idHelper');
var Event = require('./Event');
var Collection = require('../collection/Collection');
var Options = require('../opts/Options');
var Eventer = (function (_super) {
    __extends(Eventer, _super);
    function Eventer(opts) {
        var defOpts = {
            eventEmitter2Config: {
                wildcard: true
            }
        };
        this.opts = new Options(defOpts);
        this.opts.merge(opts);
        _super.call(this, this.opts.get('eventEmitter2Config'));
        this.useOnce = false;
        this.interceptors = new Collection(idHelper.newId());
        this.event = "";
    }
    Eventer.prototype.getLastEvent = function () {
        return this.event;
    };
    Eventer.getEvent = function (event) {
        if (typeof event === 'string') {
            return new Event({
                name: event
            });
        }
        return event;
    };
    Eventer.prototype.tell = function (event) {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt);
    };
    Eventer.prototype.inform = function (event, info) {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, info);
    };
    Eventer.prototype.confirm = function (event, callback) {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, callback);
    };
    Eventer.prototype.check = function (event, toCheck, callback) {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, toCheck, callback);
    };
    Eventer.prototype.ask = function (event, callback) {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, callback);
    };
    Eventer.prototype.request = function (event, request, callback) {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, request, callback);
    };
    Eventer.prototype.listen = function (event, listener) {
        return this.setupListener(event, listener);
    };
    Eventer.prototype.info = function (event, listener) {
        return this.setupListener(event, listener);
    };
    Eventer.prototype.ack = function (event, listener) {
        return this.setupListener(event, listener);
    };
    Eventer.prototype.verify = function (event, listener) {
        return this.setupListener(event, listener);
    };
    Eventer.prototype.answer = function (event, listener) {
        return this.setupListener(event, listener);
    };
    Eventer.prototype.respond = function (event, listener) {
        return this.setupListener(event, listener);
    };
    Eventer.prototype.onlyOnce = function () {
        this.useOnce = true;
        return this;
    };
    Eventer.prototype.setupListener = function (event, listener) {
        var evt = Eventer.getEvent(event);
        var instance = this;
        var args = [
            evt.getText(),
            function (emit) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                instance.interceptListener(listener, emit, args);
            }
        ];
        if (this.useOnce) {
            this.useOnce = false;
            this.once.apply(this, args);
        }
        else {
            this.on.apply(this, args);
        }
        return this;
    };
    Eventer.prototype.interceptListener = function (listener, emit, args) {
        var instance = this;
        this.interceptors.filter(function (interceptor, callback) {
            var intercept = interceptor.getEvent();
            callback(null, interceptor.getEvent().equal(emit));
        }, function (e, interceptors) {
            if (interceptors.length() === 0) {
                listener.apply(instance, args);
            }
            else {
                var stopped = false;
                async.eachSeries(interceptors.list(), function (interceptor, callback) {
                    if (!stopped) {
                        interceptor.intercept(emit, args, function (stop, updatedArgs) {
                            if (stop) {
                                stopped = true;
                            }
                            else {
                                args = updatedArgs;
                            }
                            callback(e);
                        });
                    }
                }, function (e) {
                    if (!stopped) {
                        listener.apply(instance, args);
                    }
                });
            }
        });
    };
    Eventer.prototype.dispose = function (callback) {
        //TODO
        if (!_.isUndefined(callback)) {
            process.nextTick(function () {
                callback();
            });
        }
    };
    return Eventer;
})(events.EventEmitter2);
module.exports = Eventer;
//# sourceMappingURL=Eventer.js.map