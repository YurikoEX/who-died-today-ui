
import events = require('eventemitter2');
import _ = require('lodash');
import async = require('async');

import idHelper = require('../helpers/idHelper');
import IEvent = require('../../interfaces/eventing/IEvent');
import Event = require('./Event');
import IEmit = require('../../interfaces/eventing/IEmit');
import IAm = require('../../interfaces/whoIAm/IAm');
import IInterceptor = require('../../interfaces/interception/IInterceptor');
import Collection = require('../collection/Collection');
import ICollection = require('../../interfaces/collection/ICollection');

import Options = require('../opts/Options');

import IEventer = require('../../interfaces/eventing/IEventer');
import IEventerOpts = require('../../interfaces/opts/IEventerOpts');

class Eventer extends events.EventEmitter2 implements IEventer {
    private useOnce: boolean;

    protected interceptors: ICollection<IInterceptor>;
    protected event: string;
    protected opts: Options<IEventerOpts>;

    constructor(opts?: IEventerOpts) {

        var defOpts: IEventerOpts = {
            eventEmitter2Config: {
                wildcard: true
            }
        };
        this.opts = new Options<IEventerOpts>(defOpts);
        this.opts.merge(opts);

        super(this.opts.get('eventEmitter2Config'));

        this.useOnce = false;

        this.interceptors = new Collection<IInterceptor>(idHelper.newId());
        this.event = "";
    }

    public getLastEvent(): string {
        return this.event;
    }


    private static getEvent(event: IEvent|string): IEvent {
        if (typeof event === 'string') {
            return new Event({
                name: event
            });
        }
        return <IEvent>event;
    }
    

    public tell(event: IEmit|string): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt);
    }

    public inform<infoType>(event: IEmit|string, info: infoType): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, info);
    }

    public confirm(event: IEmit|string, callback: (e: Error) => void): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, callback);
    }

    public check<checkType>(event: IEmit|string, toCheck: checkType, callback: (e: Error) => void): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, toCheck, callback);
    }

    public ask<answerType>(event: IEmit|string, callback: (e: Error, answer?: answerType) => void): boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, callback);
    }

    public request<requestType, responseType>(
        event: IEmit|string, request: requestType, callback: (e: Error, response?: responseType) => void)
    : boolean {
        var evt = Eventer.getEvent(event);
        return this.emit(evt.getText(), evt, request, callback);
    }


    public listen(event: IEvent|string, listener: () => void): IEventer {
        return this.setupListener(event, listener);
    }

    public info<infoType>(event: IEvent|string, listener: (info: infoType) => void): IEventer {
        return this.setupListener(event, listener);
    }

    public ack(event: IEvent|string, listener: (callback: (e: Error) => void) => void): IEventer {
        return this.setupListener(event, listener);
    }

    public verify<checkType>(
        event: IEvent|string, listener: (toCheck: checkType, callback: (e: Error) => void) => void)
    : IEventer {
        return this.setupListener(event, listener);
    }

    public answer<answerType>(
        event: IEvent|string, listener: (callback: (e: Error, answer?: answerType) => void) => void)
    : IEventer {
        return this.setupListener(event, listener);
    }

    public respond<requestType, responseType>(
        event: IEvent|string, 
        listener: (request: requestType, callback: (e: Error, response?: responseType) => void) => void)
    : IEventer {
        return this.setupListener(event, listener);
    }

    public onlyOnce(): IEventer {
        this.useOnce = true;
        return this;
    }

    private setupListener(event: IEvent|string, listener: Function) {
        var evt = Eventer.getEvent(event);
        var instance = this;
        var args = [
            evt.getText(),
            (emit: IEmit, ...args: any[]) => {
                instance.interceptListener(listener, emit, args);
            }
        ];
        if (this.useOnce) {
            this.useOnce = false;
            this.once.apply(this, args);
        }
        else {
            this.on.apply(this, args);
        }
        return this;
    }

    private interceptListener(listener: Function, emit: IEmit, args: any[]) {
        var instance = this;
        this.interceptors.filter((interceptor, callback) => {
            var intercept = interceptor.getEvent();
            callback(null, interceptor.getEvent().equal(emit));
        }, (e, interceptors) => {
            if (interceptors.length() === 0) {
                listener.apply(instance, args);
            }
            else {
                var stopped = false;
                async.eachSeries(interceptors.list(), (interceptor, callback: (e) => void) => {
                    if (!stopped) {
                        interceptor.intercept(emit, args, (stop, updatedArgs) => {
                            if (stop) {
                                stopped = true;
                            }
                            else {
                                args = updatedArgs;
                            }
                            callback(e);
                        });
                    }
                }, (e) => {
                    if (!stopped) {
                        listener.apply(instance, args);
                    }
                });
            }
        });
    }

    public dispose(callback?: () => void) {
        //TODO
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback();
            });
        }
    }
}

export = Eventer;
