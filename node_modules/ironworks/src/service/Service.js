var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _ = require('lodash');
var async = require('async');
var idHelper = require('../../src/helpers/idHelper');
var Comm = require('../../src/eventing/Comm');
var Collection = require('../../src/collection/Collection');
var Worker = require('../workers/Worker');
var Service = (function (_super) {
    __extends(Service, _super);
    function Service(name, opts) {
        var id = idHelper.newId();
        var defWorkerName = 'service-as-a-worker';
        _super.call(this, [], void 0, void 0, {
            id: id,
            name: _.isUndefined(opts) || _.isUndefined(opts.workerName) ? defWorkerName : opts.workerName
        });
        var defOpts = {
            dependencyCheckTimeout: 120000,
            dependencyCheckFrequency: 100,
            server: {
                port: 8080
            },
            workerName: defWorkerName
        };
        this.opts = this.opts.beAdoptedBy(defOpts, 'worker');
        this.opts.merge(opts);
        this.workers = new Collection(idHelper.newId());
        this.whoService = {
            id: id,
            name: name
        };
        this.comm = new Comm(this.whoService, {
            id: idHelper.newId(),
            name: name + '-comm'
        }, this.opts.get('workerName'), this.opts.get('comm'));
    }
    Service.prototype.start = function (dependencies, callback) {
        var instance = this;
        async.waterfall([
            function (commStarted) {
                instance.comm.start(commStarted);
            },
            function (workersStarted) {
                instance.workers.each(function (worker, workerStarted) {
                    instance.readyWorker(worker, workerStarted);
                }, workersStarted);
            }
        ], function (e) {
            if (!_.isUndefined(callback)) {
                callback(e);
            }
            instance.running = true;
            if (e === null) {
                instance.inform('ready', {
                    service: instance
                });
            }
            else {
                instance.inform('error', e);
            }
        });
    };
    Service.prototype.readyWorker = function (worker, workerStarted) {
        var instance = this;
        var errorPrefix = 'Failed to load dependencies for ' + worker.who().name + ': ';
        async.waterfall([
            function (workerInited) {
                worker.init(workerInited);
            },
            function (workerDepsLoaded) {
                var depNames = worker.getDependencyNames();
                if (depNames.length > 0) {
                    instance.workers.get({
                        names: depNames
                    }, function (e, deps) {
                        if (deps.length() < depNames.length) {
                            workerDepsLoaded(new Error(errorPrefix + 'missing - ' +
                                _.difference(depNames, _.pluck(deps.list(), 'name')).join(', ')));
                        }
                        else {
                            workerDepsLoaded(null, deps);
                        }
                    });
                }
                else {
                    workerDepsLoaded(null, new Collection(idHelper.newId()));
                }
            },
            function (workerDeps, allDepsStarted) {
                var started = new Date().getTime();
                var timeout = instance.opts.get('dependencyCheckTimeout');
                async.whilst(function () {
                    return !_.every(workerDeps.list(), function (w) {
                        return w.running;
                    });
                }, function (tryAgain) {
                    var now = new Date().getTime();
                    if ((now - started) >= timeout) {
                        tryAgain(new Error(errorPrefix + 'timeout'));
                    }
                    else {
                        setTimeout(tryAgain, instance.opts.get('dependencyCheckFrequency'));
                    }
                }, function (e) {
                    allDepsStarted(e, workerDeps);
                });
            },
            function (workerDeps, workerReady) {
                worker.start(workerDeps, function (e) {
                    if (e === null) {
                        worker.running = true;
                    }
                    workerReady(e);
                });
            }
        ], workerStarted);
    };
    Service.prototype.who = function (callback) {
        var iam = this.whoService;
        if (!_.isUndefined(callback)) {
            process.nextTick(function () {
                callback(null, iam);
            });
        }
        return iam;
    };
    Service.prototype.use = function (worker) {
        this.workers.add(worker);
        return this;
    };
    Service.prototype.inject = function (injector) {
        var instance = this;
        injector.call(this, this, function (worker) {
            instance.use.call(instance, worker);
        });
        return this;
    };
    Service.prototype.get = function (workerQuery, callback) {
        this.workers.get(workerQuery, callback);
        return this;
    };
    Service.prototype.getLastEvent = function () {
        return this.comm.getLastEvent();
    };
    Service.prototype.disposeWorkers = function (callback) {
        var _this = this;
        var instance = this;
        async.series([
            function (cb) {
                async.each(_this.workers.list(), function (w, wcb) {
                    w.dispose(wcb);
                }, cb);
            },
            function (cb) {
                instance.workers.dispose(cb);
            },
            function (cb) {
                instance.comm.dispose(cb);
            }
        ], callback);
    };
    Service.prototype.dispose = function (callback) {
        var _this = this;
        this.disposeWorkers(function () {
            _super.prototype.dispose.call(_this, callback);
        });
    };
    return Service;
})(Worker);
module.exports = Service;
//# sourceMappingURL=Service.js.map