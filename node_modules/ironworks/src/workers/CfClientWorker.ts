
import _ = require('lodash');
import ioClient = require('socket.io-client');

import idHelper = require('../helpers/idHelper');

import ICfClient = require('../../interfaces/workers/ICfClient');
import IComm = require('../../interfaces/eventing/IComm');
import IAm = require('../../interfaces/whoIAm/IAm');
import ICollection = require('../../interfaces/collection/ICollection');
import IDependency = require('../../interfaces/workers/IDependency');
import IWorker = require('../../interfaces/workers/IWorker');

import ICfClientWorker = require('../../interfaces/workers/ICfClientWorker');
import ICfClientWorkerOpts = require('../../interfaces/opts/ICfClientWorkerOpts');
import Worker = require('./Worker');

class CfClientWorker extends Worker implements ICfClientWorker{
    public userProvidedServices: ICfClient[];

    constructor(comm: IComm, whoService: IAm, opts?: ICfClientWorkerOpts) {
        super([], comm, whoService, {
            id: idHelper.newId(),
            name: 'iw-cf-clients'
        });

        var defOpts: ICfClientWorkerOpts = {
            iwProperty: 'iw',
            vcapServices: 'VCAP_SERVICES'
        };
        this.opts = this.opts.beAdoptedBy<ICfClientWorkerOpts>(defOpts, 'worker');
        this.opts.merge(opts);
    }

    public init(callback: (e: Error) => void) {
        this.getIwUserProvidedServices();
        super.init(callback);
    }

    private getIwUserProvidedServices() {
        var services = JSON.parse(process.env[this.opts.get<string>('vcapServices')]);

        var instance = this;
        this.userProvidedServices = _.reduce(services['user-provided'], (memo:ICfClient[], service) => {
            if(service.credentials[instance.opts.get<string>('iwProperty')]==="true"){
                memo.push(<ICfClient>{
                    serviceName: service.credentials.serviceName,
                    protocol: service.credentials.protocol,
                    host: service.credentials.host,
                    port: service.credentials.port,
                    route: service.credentials.route,
                    token: service.credentials.token
                });
            }
            return memo;
        },[]);
    }

    private static constructServiceUrl(service:ICfClient){
        return service.protocol + '://' + service.host + ':' + service.port + (_.isUndefined(service.route) ? '' : service.route[0] === '/' ? '' : '/' + service.route);
    }

    public start(dependencies: ICollection<IDependency<IWorker>>, callback?: (e: Error) => void) {
        var instance = this;

        _.each(instance.userProvidedServices,(ups)=>{
            if (instance.whoService.name === ups.serviceName) {
                return;
            }
            instance.comm.listen(instance.comm.prefix() + '.' + ups.serviceName + '.*.*.*', (...args: any[]) => {
                var event = instance.getCommEmit(instance.comm.getLastEvent());
                var service:ICfClient = _.find(instance.userProvidedServices,(ups)=>{return ups.serviceName===event.service;});
                var serviceUrl = CfClientWorker.constructServiceUrl(service);
                var client = ioClient(serviceUrl);
                client.emit.apply(client, [ event.getText() ].concat(args));
            });
        });
        super.start(dependencies, callback);
    }

    public dispose(callback?: () => void) {
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback();
            });
        }
    }
}

export = CfClientWorker;
