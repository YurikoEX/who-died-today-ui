var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var path = require('path');
var _ = require('lodash');
var hapi = require('hapi');
var idHelper = require('..//helpers/idHelper');
var CommEmit = require('..//eventing/CommEmit');
var Worker = require('../../src/workers/Worker');
var HttpWorker = (function (_super) {
    __extends(HttpWorker, _super);
    function HttpWorker(comm, whoService, opts) {
        _super.call(this, [], comm, whoService, {
            id: idHelper.newId(),
            name: 'iw-http'
        });
        var defOpts = {
            port: process.env.VCAP_APP_PORT
        };
        this.opts = this.opts.beAdoptedBy(defOpts, 'worker');
        this.opts.merge(opts);
    }
    HttpWorker.prototype.init = function (callback) {
        var instance = this;
        this.httpServer = new hapi.Server(this.opts.get('hapi'));
        this.httpServer.connection({
            port: this.opts.get('port')
        });
        var serveApi = this.opts.has('apiUri');
        if (serveApi) {
            var api = this.opts.get('apiUri');
            if (api[0] !== '/') {
                api = '/' + api;
            }
            if (api[api.length - 1] === '/') {
                api = api.substring(0, api.length - 1);
            }
            this.httpServer.route({
                method: 'POST',
                path: api + '/{prefix}/{service}/{method}/{worker}/{event}',
                config: {
                    payload: {
                        allow: 'application/json',
                        parse: true
                    }
                },
                handler: function (req, reply) {
                    instance.handleApiPost(req, reply);
                }
            });
            this.httpServer.route({
                method: 'GET',
                path: api + '/{prefix}/{service}/{method}/{worker}/{event}',
                handler: function (req, reply) {
                    instance.handleApiGet(req, reply);
                }
            });
        }
        var servePublicRoot = this.opts.has('hapi.connections.routes.files.relativeTo')
            && this.opts.has('rootSitePagePath');
        if (servePublicRoot) {
            this.httpServer.route({
                method: 'GET',
                path: '/{p*}',
                handler: function (req, reply) {
                    if (req.path === '/') {
                        req.path = instance.opts.get('rootSitePagePath');
                    }
                    var root = instance.opts.get('hapi.connections.routes.files.relativeTo');
                    var filePath = path.join(root, req.path);
                    reply.file(filePath);
                }
            });
        }
        else {
            this.httpServer.route({
                method: 'GET',
                path: '/',
                handler: function (req, reply) {
                    reply(200);
                }
            });
        }
        _super.prototype.init.call(this, callback);
    };
    HttpWorker.prototype.getCommEmitFromRequest = function (req) {
        return new CommEmit({
            id: idHelper.newId(),
            emitter: {
                id: _.isUndefined(req.query.myId) ? this.me.id : req.query.myId,
                name: _.isUndefined(req.query.myName) ? this.me.name : req.query.myName
            },
            timestamp: new Date().getTime(),
            prefix: req.paramsArray[0],
            service: req.paramsArray[1],
            method: req.paramsArray[2],
            worker: req.paramsArray[3],
            name: req.paramsArray[4]
        });
    };
    HttpWorker.prototype.handleApiGet = function (req, reply) {
        var event = this.getCommEmitFromRequest(req);
        switch (event.method) {
            case 'confirm':
                this.confirm(event, function (e) {
                    reply(e === null ? 200 : e);
                });
                break;
            case 'ask':
                this.ask(event, function (e, answer) {
                    reply(e, answer);
                });
                break;
            default:
                reply(404);
                break;
        }
    };
    HttpWorker.prototype.handleApiPost = function (req, reply) {
        var event = this.getCommEmitFromRequest(req);
        switch (event.method) {
            case 'tell':
                this.tell(event);
                reply(200);
                break;
            case 'inform':
                this.inform(event, req.payload);
                reply(200);
                break;
            case 'confirm':
                this.confirm(event, function (e) {
                    reply(e === null ? 200 : e);
                });
                break;
            case 'ask':
                this.ask(event, function (e, answer) {
                    reply(e, answer);
                });
                break;
            case 'request':
                this.request(event, req.payload, function (e, response) {
                    reply(e, response);
                });
                break;
            default:
                reply(404);
                break;
        }
    };
    HttpWorker.prototype.start = function (dependencies, callback) {
        var _this = this;
        this.httpServer.start(function (e) {
            if (_.isUndefined(e)) {
                e = null;
            }
            if (e !== null) {
                _this.inform('error', e);
            }
            _super.prototype.start.call(_this, dependencies, callback);
        });
    };
    HttpWorker.prototype.dispose = function (callback) {
        if (!_.isUndefined(this.httpServer)) {
            this.httpServer.stop(void 0, function () {
                if (!_.isUndefined(callback)) {
                    callback();
                }
            });
        }
        else {
            if (!_.isUndefined(callback)) {
                process.nextTick(function () {
                    callback();
                });
            }
        }
    };
    return HttpWorker;
})(Worker);
module.exports = HttpWorker;
//# sourceMappingURL=HttpWorker.js.map