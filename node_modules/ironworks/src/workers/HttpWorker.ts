
import path = require('path');

import _ = require('lodash');
import hapi = require('hapi');

import IComm = require('../../interfaces/eventing/IComm');
import idHelper = require('..//helpers/idHelper');
import IAm = require('../../interfaces/whoIAm/IAm');
import Options = require('../opts/Options');
import ICommEmit = require('../../interfaces/eventing/ICommEmit');
import CommEmit = require('..//eventing/CommEmit');
import IDependency = require('../../interfaces/workers/IDependency');
import ICollection = require('../../interfaces/collection/ICollection');
import IWorker = require('../../interfaces/workers/IWorker');

import Worker = require('../../src/workers/Worker');

import IHttpWorker = require('../../interfaces/workers/IHttpWorker');
import IHttpWorkerOpts = require('../../interfaces/opts/IHttpWorkerOpts');

class HttpWorker extends Worker implements IHttpWorker {
    public httpServer: hapi.Server;

    constructor(comm: IComm, whoService: IAm, opts?: IHttpWorkerOpts) {
        super([], comm, whoService, {
            id: idHelper.newId(),
            name: 'iw-http'
        });

        var defOpts: IHttpWorkerOpts = {
            port: process.env.VCAP_APP_PORT
        };
        this.opts = this.opts.beAdoptedBy<IHttpWorkerOpts>(defOpts, 'worker');
        this.opts.merge(opts);
    }

    public init(callback?: (e: Error) => void) {
        var instance = this;

        this.httpServer = new hapi.Server(this.opts.get<hapi.IServerOptions>('hapi'));
        this.httpServer.connection({
            port: this.opts.get<number>('port')
        });

        var serveApi = this.opts.has('apiUri');
        if (serveApi) {
            var api = this.opts.get<string>('apiUri');
            if (api[0] !== '/') {
                api = '/' + api;
            }
            if (api[api.length - 1] === '/') {
                api = api.substring(0, api.length - 1);
            }
            this.httpServer.route({
                method: 'POST',
                path: api + '/{prefix}/{service}/{method}/{worker}/{event}',
                config: {
                    payload: {
                        allow: 'application/json',
                        parse: true
                    },
                },
                handler: (req: hapi.Request, reply: hapi.IReply) => {
                    instance.handleApiPost(req, reply);
                }
            });
            this.httpServer.route({
                method: 'GET',
                path: api + '/{prefix}/{service}/{method}/{worker}/{event}',
                handler: (req: hapi.Request, reply: hapi.IReply) => {
                    instance.handleApiGet(req, reply);
                }
            });
        }
        var servePublicRoot = this.opts.has('hapi.connections.routes.files.relativeTo')
            && this.opts.has('rootSitePagePath');
        if (servePublicRoot) {
            this.httpServer.route({
                method: 'GET',
                path: '/{p*}',
                handler: (req: hapi.Request, reply: hapi.IReply) => {
                    if (req.path === '/') {
                        req.path = instance.opts.get<string>('rootSitePagePath');
                    }
                    var root = instance.opts.get<string>('hapi.connections.routes.files.relativeTo');
                    var filePath = path.join(root, req.path);
                    reply.file(filePath);
                }
            });
        }
        else {
            this.httpServer.route({
                method: 'GET',
                path: '/',
                handler: (req: hapi.Request, reply: hapi.IReply) => {
                    reply(200);
                }
            });
        }
        super.init(callback);
    }

    private getCommEmitFromRequest(req): ICommEmit {
        return new CommEmit({
            id: idHelper.newId(),
            emitter: {
                id: _.isUndefined(req.query.myId) ? this.me.id : req.query.myId,
                name: _.isUndefined(req.query.myName) ? this.me.name : req.query.myName
            },
            timestamp: new Date().getTime(),
            prefix: req.paramsArray[0],
            service: req.paramsArray[1],
            method: req.paramsArray[2],
            worker: req.paramsArray[3],
            name: req.paramsArray[4]
        });
    }

    private handleApiGet(req: hapi.Request, reply: hapi.IReply) {
        var event = this.getCommEmitFromRequest(req);
        switch (event.method) {
            case 'confirm':
                this.confirm(event, (e) => {
                    reply(e === null ? 200 : e);
                });
                break;
            case 'ask':
                this.ask(event, (e, answer) => {
                    reply(e, answer);
                });
                break;
            default:
                reply(404);
                break;
        }
    }

    private handleApiPost(req: hapi.Request, reply: hapi.IReply) {
        var event = this.getCommEmitFromRequest(req);
        switch (event.method) {
            case 'tell':
                this.tell(event);
                reply(200);
                break;
            case 'inform':
                this.inform(event, req.payload);
                reply(200);
                break;
            case 'confirm':
                this.confirm(event, (e) => {
                    reply(e === null ? 200 : e);
                });
                break;
            case 'ask':
                this.ask(event, (e, answer) => {
                    reply(e, answer);
                });
                break;
            case 'request':
                this.request(event, req.payload, (e, response) => {
                    reply(e, response);
                });
                break;
            default:
                reply(404);
                break;
        }
    }

    public start(dependencies: ICollection<IDependency<IWorker>>, callback?: (e: Error) => void) {
        this.httpServer.start((e: Error) => {
            if (_.isUndefined(e)) {
                e = null;
            }
            if (e !== null) {
                this.inform<Error>('error', e);
            }
            super.start(dependencies, callback);
        });
    }

    public dispose(callback?: () => void) {
        if (!_.isUndefined(this.httpServer)) {
            this.httpServer.stop(void 0, () => {
                if (!_.isUndefined(callback)) {
                    callback();
                }
            });
        }
        else {
            if (!_.isUndefined(callback)) {
                process.nextTick(() => {
                    callback();
                });
            }
        }
    }
}

export = HttpWorker;
