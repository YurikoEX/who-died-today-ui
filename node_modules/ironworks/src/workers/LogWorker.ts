
import _ = require('lodash');
import circular = require('circular');

import idHelper = require('../helpers/idHelper');

import ICollection = require('../../interfaces/collection/ICollection');
import Collection = require('../collection/Collection');
import IComm = require('../../interfaces/eventing/IComm');
import IAm = require('../../interfaces/whoIAm/IAm');
import IDependency = require('../../interfaces/workers/IDependency');
import IWorker = require('../../interfaces/workers/IWorker');
import ICommEmit = require('../../interfaces/eventing/ICommEmit');

import ILogWorker = require('../../interfaces/workers/ILogWorker');
import ILogWorkerOpts = require('../../interfaces/opts/ILogWorkerOpts');
import Worker = require('./Worker');

class LogWorker extends Worker implements ILogWorker {
    private static writeStdout: Function;
    private static writeStderr: Function;

    constructor(comm: IComm, whoService: IAm, writeStdout?: Function, writeStderr?: Function, opts?: ILogWorkerOpts) {
        super([], comm, whoService, {
            id: idHelper.newId(),
            name: 'iw-log-to-console'
        });
        var defOpts: ILogWorkerOpts = {};
        this.opts = this.opts.beAdoptedBy<ILogWorkerOpts>(defOpts, 'worker');
        this.opts.merge(opts);

        if (_.isUndefined(writeStdout) && _.isUndefined(LogWorker.writeStdout)) {
            LogWorker.writeStdout = console.log;
        }
        else {
            LogWorker.writeStdout = writeStdout;
        }
        if (_.isUndefined(writeStderr) && _.isUndefined(LogWorker.writeStderr)) {
            LogWorker.writeStderr = console.error;
        }
        else {
            LogWorker.writeStderr = writeStderr;
        }
    }

    public start(dependencies: ICollection<IDependency<IWorker>>, callback: (e: Error) => void) {
        this.comm.intercept(this.comm.prefix() + '.*.*.*.*').listen(
            (...args: any[]) => {
                var meta = args[0];
                var nextIndex = 1;
                var emitterObj, cb, next;
                if (args.length === 5) {
                    emitterObj = args[1];
                    cb = args[2];
                    nextIndex = 3;
                }
                else if (args.length === 4) {
                    emitterObj = args[1];
                    nextIndex = 2;
                }
                next = args[nextIndex];
                var nextArgs = [];
                if (!_.isUndefined(emitterObj)) {
                    nextArgs.push(emitterObj);
                    if (!_.isUndefined(cb)) {
                        nextArgs.push((...listenerArgs: any[]) => {
                            var e = listenerArgs[0];
                            var listenerRes;
                            if (listenerArgs.length > 1) {
                                listenerRes = listenerArgs[1];
                            }
                            if (e !== null) {
                                LogWorker.error(meta, e, emitterObj);
                            }
                            else {
                                LogWorker.log(meta, emitterObj, listenerRes);
                            }
                            cb(e, listenerRes);
                        });
                    }
                    else {
                        LogWorker.log(meta, emitterObj);
                    }
                }
                else {
                    LogWorker.log(meta);
                }
                next.apply(void 0, nextArgs);
            });
        super.start(dependencies, callback);
    }

    private static log(meta: ICommEmit, emitterObj?: any, listenerRes?: any) {
        process.nextTick(() => {
            var entry: any = {
                meta: meta
            };
            if (!_.isUndefined(emitterObj)) {
                entry.emitted = emitterObj;
            }
            if (!_.isUndefined(listenerRes)) {
                entry.result = listenerRes;
            }
            var json;
            try {
                json = JSON.stringify(entry);
            }
            catch (e) {
                json = JSON.stringify(entry, circular());
            }
            LogWorker.writeStdout(json);
        });
    }

    private static error(meta: ICommEmit, error: Error, emitterObj?: any) {
        process.nextTick(() => {
            var entry: any = {
                meta: meta,
                error: error
            };
            if (!_.isUndefined(emitterObj)) {
                entry.emitted = emitterObj;
            }
            var json;
            try {
                json = JSON.stringify(entry);
            }
            catch (e) {
                json = JSON.stringify(entry, circular());
            }
            LogWorker.writeStderr(json);
        });
    }
}

export = LogWorker;
