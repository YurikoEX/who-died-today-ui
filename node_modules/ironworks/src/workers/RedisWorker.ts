
import _ = require('lodash');

import redis = require('redis');

import idHelper = require('../helpers/idHelper');
import IComm = require('../../interfaces/eventing/IComm');
import IAm = require('../../interfaces/whoIAm/IAm');
import ICollection = require('../../interfaces/collection/ICollection');
import IDependency = require('../../interfaces/workers/IDependency');
import IWorker = require('../../interfaces/workers/IWorker');

import IRedisWorker = require('../../interfaces/workers/IRedisWorker');
import IRedisWorkerOpts = require('../../interfaces/opts/IRedisWorkerOpts');
import Worker = require('./Worker');

import IRedisService = require('../../interfaces/workers/IRedisService')

interface setInfo{
    key:string;
    value:string|any;
}



class RedisWorker extends Worker implements IRedisWorker{
    public redisService: IRedisService;
    public client: redis.RedisClient;

    constructor(comm: IComm, service: IAm, opts?: IRedisWorkerOpts) {
        super([], comm, service, {
            id: idHelper.newId(),
            name: 'iw-redis'
        });

        var defOpts: IRedisWorkerOpts = {
            vcapServices: 'VCAP_SERVICES',
            redisProp: 'p-redis'
        };
        this.opts = this.opts.beAdoptedBy<IRedisWorkerOpts>(defOpts, 'worker');
        this.opts.merge(opts);
    }

    public init(callback: (e: Error) => void) {
        var instance = this;
        instance.getRedisCloudService();

        instance.info<setInfo>("set",(info:setInfo) => {
            var stringData;
            if(typeof info.value === "string"){
                stringData = info.value;
            }
            else {
                stringData = JSON.stringify(info.value);
            }
            instance.client.set(info.key,stringData);
        });

        instance.respond("get",(key,cb) => {
            instance.client.get(key,function(err,results){
                instance.parseResponseResults(cb,err,results);
            });
        });

        instance.respond<setInfo,any>("hmset",(data:setInfo,cb) => {
            instance.client.hmset(data.key,data.value,function(err,results){
                instance.parseResponseResults(cb,err,results);
            });
        });

        instance.respond<string,any>("hgetall",(key:string,cb) => {
            instance.client.hgetall(key,function(err,results){
                instance.parseResponseResults(cb,err,results);
            });
        });

        instance.connect(function(err){
            if (!_.isUndefined(callback)) {
                callback(err);
            }
        });
    }

    private parseResponseResults(cb, err, results) {
        if(err){
            cb(err);
        } else {
            var err;
            var obj = results;
            try{
                if(typeof obj === 'string' && obj.length > 0 && (obj[0]==='"' || obj[0]==='[' || obj[0]==='{'))
                    obj = JSON.parse(results);
            }catch(e){
                err=e;
            }
            cb(err,obj);
        }
    }

    private connect(cb) {
        this.client = redis.createClient(this.redisService.port,this.redisService.hostname);
        if(!_.isUndefined(this.redisService.password)){
            this.client.auth(this.redisService.password, function(err){
                cb(err);
            });
        } else {
            cb(null);
        }

    }

    private getRedisCloudService() {
        var services = JSON.parse(process.env[this.opts.get<string>('vcapServices')]);

        var instance = this;
        this.redisService = _.first(_.reduce(services[this.opts.get<string>('redisProp')], (memo:IRedisService[], service) => {
            memo.push(<IRedisService>{
                hostname: service.credentials.hostname,
                port: service.credentials.port,
                password: service.credentials.route
            });
            return memo;
        },[]));
    }



    public start(dependencies: ICollection<IDependency<IWorker>>, callback?: (e: Error) => void) {
        var instance = this;


        this.tell('ready');
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback(null);
            });
        }

    }

    public dispose(callback?: () => void) {
        this.client.end();
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback();
            });
        }
    }
}

export = RedisWorker;
