var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _ = require('lodash');
var io = require('socket.io');
var ioWildcard = require('socketio-wildcard')();
var idHelper = require('../../src/helpers/idHelper');
var Worker = require('../../src/workers/Worker');
var SocketWorker = (function (_super) {
    __extends(SocketWorker, _super);
    function SocketWorker(comm, whoService, opts) {
        _super.call(this, [
            'iw-http'
        ], comm, whoService, {
            id: idHelper.newId(),
            name: 'iw-socket'
        });
        /**
         * TODO: remove... change interface as well
         * @type {{externalServiceUrlEnvVarPrefix: string}}
         */
        var defOpts = {};
        this.opts = this.opts.beAdoptedBy(defOpts, 'worker');
        this.opts.merge(opts);
    }
    SocketWorker.prototype.start = function (dependencies, callback) {
        var _this = this;
        var instance = this;
        dependencies.get({
            names: ['iw-http']
        }, function (e, results) {
            if (e === null) {
                instance.socketServer = io(results.list()[0].httpServer.listener);
                instance.socketServer.use(ioWildcard);
                instance.socketServer.on('connection', function (socket) {
                    socket.on('error', function (e) {
                        //TODO
                        console.error(e);
                    });
                    socket.on('*', function (event) {
                        var eventName = event.data.shift();
                        var commEvent = instance.getCommEmit(eventName);
                        if (commEvent.service === instance.whoService.name) {
                            event.data.unshift(commEvent);
                            var method = void 0;
                            switch (commEvent.method) {
                                case 'tell':
                                    method = instance.tell;
                                    break;
                                case 'inform':
                                    method = instance.inform;
                                    break;
                                case 'confirm':
                                    method = instance.confirm;
                                    break;
                                case 'ask':
                                    method = instance.ask;
                                    break;
                                case 'request':
                                    method = instance.request;
                                    break;
                            }
                            if (_.isUndefined(method)) {
                                instance.inform('error', new Error('unknown method: ' + commEvent.method));
                            }
                            else {
                                method.apply(instance, event.data);
                            }
                        }
                    });
                });
            }
            else {
                instance.inform('error', e);
            }
            _super.prototype.start.call(_this, dependencies, callback);
        });
    };
    SocketWorker.prototype.dispose = function (callback) {
        if (!_.isUndefined(this.socketServer)) {
            this.socketServer.close();
        }
        if (!_.isUndefined(callback)) {
            process.nextTick(function () {
                callback();
            });
        }
    };
    return SocketWorker;
})(Worker);
module.exports = SocketWorker;
//# sourceMappingURL=SocketWorker.js.map