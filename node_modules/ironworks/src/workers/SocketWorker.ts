
import path = require('path');

import _ = require('lodash');
import io = require('socket.io');

var ioWildcard = require('socketio-wildcard')();

import IComm = require('../../interfaces/eventing/IComm');
import Comm = require('../../src/eventing/Comm');
import idHelper = require('../../src/helpers/idHelper');
import IAm = require('../../interfaces/whoIAm/IAm');
import Options = require('../../src/opts/Options');
import ICommEvent = require('../../interfaces/eventing/ICommEvent');
import IDependency = require('../../interfaces/workers/IDependency');
import ICollection = require('../../interfaces/collection/ICollection');
import IWorker = require('../../interfaces/workers/IWorker');
import IHttpWorker = require('../../interfaces/workers/IHttpWorker');

import Worker = require('../../src/workers/Worker');

import ISocketWorker = require('../../interfaces/workers/ISocketWorker');
import ISocketWorkerOpts = require('../../interfaces/opts/ISocketWorkerOpts');

class SocketWorker extends Worker implements ISocketWorker {
    public socketServer: any; //TODO: how do we type this?

    constructor(comm: IComm, whoService: IAm, opts?: ISocketWorkerOpts) {
        super([
            'iw-http'
        ], comm, whoService, {
            id: idHelper.newId(),
            name: 'iw-socket'
        });

        /**
         * TODO: remove... change interface as well
         * @type {{externalServiceUrlEnvVarPrefix: string}}
         */
        var defOpts: ISocketWorkerOpts = {
        };
        this.opts = this.opts.beAdoptedBy<ISocketWorkerOpts>(defOpts, 'worker');
        this.opts.merge(opts);
    }

    public start(dependencies: ICollection<IDependency<IWorker>>, callback?: (e: Error) => void) {
        var instance = this;
        dependencies.get({
            names: [ 'iw-http' ]
        }, (e, results: ICollection<IHttpWorker>) => {
            if (e === null) {

                instance.socketServer = io(results.list()[0].httpServer.listener);
                instance.socketServer.use(ioWildcard);
                instance.socketServer.on('connection', (socket) => {
                    socket.on('error', (e) => {
                        //TODO
                        console.error(e);
                    });
                    socket.on('*', (event: any) => {
                        var eventName = event.data.shift();
                        var commEvent = instance.getCommEmit(eventName);
                        if (commEvent.service === instance.whoService.name) {
                            event.data.unshift(commEvent);
                            var method: Function = void 0;
                            switch (commEvent.method) {
                                case 'tell':
                                    method = instance.tell;
                                    break;
                                case 'inform':
                                    method = instance.inform;
                                    break;
                                case 'confirm':
                                    method = instance.confirm;
                                    break;
                                case 'ask':
                                    method = instance.ask;
                                    break;
                                case 'request':
                                    method = instance.request;
                                    break;
                            }
                            if (_.isUndefined(method)) {
                                instance.inform<Error>('error', new Error('unknown method: ' + commEvent.method));
                            }
                            else {
                                method.apply(instance, event.data);
                            }
                        }
                    });
                });
            }
            else {
                instance.inform<Error>('error', e);
            }
            super.start(dependencies, callback);
        });
    }

    public dispose(callback?: () => void) {
        if (!_.isUndefined(this.socketServer)) {
            this.socketServer.close();
        }
        if (!_.isUndefined(callback)) {
            process.nextTick(() => {
                callback();
            });
        }
    }
}

export = SocketWorker;
